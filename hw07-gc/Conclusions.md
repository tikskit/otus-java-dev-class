
Сборщик | Выделенная память | Количество сборок Young | Время сборки Young | Количество сборок Old | Время сборки Old | Garbage collection overhead
--------|-------------------|-------------------------|--------------------|-----------------------|----------------- |-----------------------------
UseParallelGC|512|3|0.175|8|1.894|0.69%
UseG1GC|512|55|1.101|25|5.177|2.09%
UseParallelGC|256|3|0.128|5|0.717|0.28%
UseG1GC|256|25|0.532|7|0.873|0.47%

Оба GC для сборки мусора среди молодого поколения объектов используют одинаковый алгоритм - как в Serial Collector, но в
нескольких потоках. При этом на 512мб памяти Parallel произвел 3 сборки мусора за 0.175 секунды, а G1 произвел 55 сборки 
за 1.101 секунды. 

Для сборки мусора среди старого поколения объектов Parallel использует Mark-sweep-compact алгоритм, такой же, как в 
Serial Collector, но многопоточный. При этом он произвел 8  сборок за 1.894 секунды.

G1 для сборки мусора в старом поколении использовал более сложный алгоритм Concurrent Mark-sweep collector, произвел 25 
сборку за 5.177 секунды.

Мой алгоритм удаляет и старые и новые объекты, поэтому слабая гипотеза о поколениях не соблюдается, что, видимо, 
не дает сборщикам мусора работать более эффективно, особенно G1.

Несмотря на то, что Parallel и G1 для сборки мусора в молодом поколении используют один и тот же алгоритм, Parallel 
сделал 3 сборки за 0.175 секунд, а G1 55 сборки за 1.101 секунду.  

Для сборки в старом поколении более простой алгоритм Parallel также оказался более эффективным, чем Concurrent 
Mark-sweep collector в G1. 

Таким образом, в данном примере сборщик мусора Parallel работает лучше, чем g1.